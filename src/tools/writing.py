"""Paper writing tools - simple utilities to help format LaTeX content.

These tools DO NOT generate content - content is generated by the LLM in chat.
These tools help with:
- Estimating structure (how many words, figures, etc.)
- Formatting LaTeX tables from data
- Adding citations from cached papers
- Structuring sections
"""

import json
from datetime import datetime
from pathlib import Path
from typing import Optional

from src.db.papers_cache import papers_cache
from src.db.experiments_db import experiments_db


async def estimate_paper_structure(
    target_pages: int = 9,
    conference: str = "neurips",
) -> str:
    """Estimate word counts and figures for a paper of given length.
    
    Returns target word counts per section to help guide writing.
    """
    words_per_page = 550
    total_words = target_pages * words_per_page
    
    # Standard academic paper section ratios
    structure = {
        "target_pages": target_pages,
        "total_words": total_words,
        "sections": {
            "abstract": {"words": 200, "ratio": 0.04},
            "introduction": {"words": int(total_words * 0.15), "ratio": 0.15},
            "related_work": {"words": int(total_words * 0.12), "ratio": 0.12},
            "method": {"words": int(total_words * 0.28), "ratio": 0.28},
            "experiments": {"words": int(total_words * 0.32), "ratio": 0.32},
            "conclusion": {"words": int(total_words * 0.06), "ratio": 0.06},
        },
        "recommended_figures": min(8, target_pages - 1),
        "recommended_tables": min(4, target_pages // 2),
        "recommended_citations": 30 + target_pages * 3,
    }
    
    return json.dumps(structure, indent=2)


async def format_results_table(
    results: dict,
    caption: str = "Experimental results",
    label: str = "tab:results",
    bold_best: bool = True,
) -> str:
    """Format experiment results as a LaTeX table.
    
    Args:
        results: Dict of {method_name: {metric: value, ...}}
        caption: Table caption
        label: LaTeX label
        bold_best: Whether to bold the best value per column
    
    Returns:
        LaTeX table code
    """
    if not results:
        return json.dumps({"error": "No results provided"})
    
    # Extract metrics from first result
    first_method = list(results.keys())[0]
    metrics = [k for k in results[first_method].keys() 
               if k not in ["values", "std", "train_time", "pred_time"]]
    
    if not metrics:
        metrics = list(results[first_method].keys())
    
    # Find best values per metric
    best_values = {}
    if bold_best:
        for metric in metrics:
            values = []
            for method, data in results.items():
                if isinstance(data, dict) and metric in data:
                    val = data[metric]
                    if isinstance(val, (int, float)):
                        values.append(val)
            if values:
                # Assume higher is better (can be customized)
                best_values[metric] = max(values)
    
    # Build table
    num_metrics = len(metrics)
    latex = f"""\\begin{{table}}[t]
\\centering
\\caption{{{caption}}}
\\label{{{label}}}
\\begin{{tabular}}{{l{'c' * num_metrics}}}
\\toprule
Method & {' & '.join(metrics)} \\\\
\\midrule
"""
    
    for method, data in results.items():
        row = [method.replace("_", "\\_")]
        for metric in metrics:
            if isinstance(data, dict) and metric in data:
                val = data[metric]
                if isinstance(val, float):
                    formatted = f"{val:.4f}"
                    if bold_best and metric in best_values and abs(val - best_values[metric]) < 0.0001:
                        formatted = f"\\textbf{{{formatted}}}"
                else:
                    formatted = str(val)
            else:
                formatted = "-"
            row.append(formatted)
        latex += " & ".join(row) + " \\\\\n"
    
    latex += """\\bottomrule
\\end{tabular}
\\end{table}"""
    
    return json.dumps({
        "latex": latex,
        "methods": list(results.keys()),
        "metrics": metrics,
    }, indent=2)


async def format_ablation_table(
    ablations: dict,
    full_model_name: str = "Full model",
    caption: str = "Ablation study",
    label: str = "tab:ablation",
) -> str:
    """Format ablation results as a LaTeX table.
    
    Args:
        ablations: Dict of {variant_name: {metric: value, ...}}
        full_model_name: Name of the full model variant
        caption: Table caption
        label: LaTeX label
    """
    if not ablations:
        return json.dumps({"error": "No ablation results provided"})
    
    # Get metrics
    first_variant = list(ablations.keys())[0]
    metrics = list(ablations[first_variant].keys()) if isinstance(ablations[first_variant], dict) else ["score"]
    
    # Get full model baseline
    baseline = ablations.get(full_model_name, {})
    
    latex = f"""\\begin{{table}}[t]
\\centering
\\caption{{{caption}}}
\\label{{{label}}}
\\begin{{tabular}}{{l{'c' * len(metrics)}{'c' if baseline else ''}}}
\\toprule
Configuration & {' & '.join(metrics)}{' & $\\Delta$' if baseline else ''} \\\\
\\midrule
"""
    
    for variant, data in ablations.items():
        row = [variant.replace("_", "\\_")]
        for metric in metrics:
            if isinstance(data, dict) and metric in data:
                val = data[metric]
                row.append(f"{val:.4f}" if isinstance(val, float) else str(val))
            else:
                row.append("-")
        
        # Add delta column if we have baseline
        if baseline and variant != full_model_name:
            if metrics and metrics[0] in data and metrics[0] in baseline:
                delta = data[metrics[0]] - baseline[metrics[0]]
                row.append(f"{delta:+.2f}")
            else:
                row.append("-")
        elif baseline:
            row.append("--")
        
        latex += " & ".join(row) + " \\\\\n"
    
    latex += """\\bottomrule
\\end{tabular}
\\end{table}"""
    
    return json.dumps({"latex": latex}, indent=2)


async def get_citations_for_topic(
    topic: str,
    max_citations: int = 10,
) -> str:
    """Get relevant citations from cached papers for a topic.
    
    Returns BibTeX entries and citation keys to use in text.
    """
    # Search cached papers
    papers = await papers_cache.search(topic, max_results=max_citations)
    
    if not papers:
        # Try to get recent papers if search fails
        papers = await papers_cache.get_recent(limit=max_citations)
    
    citations = []
    bibtex = ""
    
    for paper in papers[:max_citations]:
        # Generate citation key
        first_author = paper.authors[0].split()[-1].lower() if paper.authors else "unknown"
        year = paper.published[:4] if paper.published else "2024"
        cite_key = f"{first_author}{year}"
        
        # Avoid duplicate keys
        base_key = cite_key
        counter = 1
        while any(c["key"] == cite_key for c in citations):
            cite_key = f"{base_key}_{counter}"
            counter += 1
        
        citations.append({
            "key": cite_key,
            "title": paper.title,
            "authors": paper.authors[:3],
            "year": year,
            "arxiv_id": paper.arxiv_id,
        })
        
        # Generate BibTeX
        authors_str = " and ".join(paper.authors[:5]) if paper.authors else "Unknown"
        bibtex += f"""
@article{{{cite_key},
  title={{{paper.title}}},
  author={{{authors_str}}},
  year={{{year}}},
  journal={{arXiv preprint arXiv:{paper.arxiv_id or 'unknown'}}}
}}
"""
    
    return json.dumps({
        "topic": topic,
        "count": len(citations),
        "citations": citations,
        "bibtex": bibtex.strip(),
        "usage": "Use \\cite{key} or \\citet{key} in your text",
    }, indent=2)


async def format_figure(
    figure_path: str,
    caption: str,
    label: str,
    width: str = "0.8\\textwidth",
    position: str = "t",
) -> str:
    """Generate LaTeX code for including a figure.
    
    Args:
        figure_path: Path to figure file
        caption: Figure caption
        label: LaTeX label (e.g., "fig:architecture")
        width: Figure width
        position: Float position (t, b, h, p)
    """
    latex = f"""\\begin{{figure}}[{position}]
\\centering
\\includegraphics[width={width}]{{{figure_path}}}
\\caption{{{caption}}}
\\label{{{label}}}
\\end{{figure}}"""
    
    return json.dumps({
        "latex": latex,
        "reference": f"Figure~\\ref{{{label}}}",
    }, indent=2)


async def format_algorithm(
    steps: list[str],
    caption: str,
    label: str = "alg:main",
) -> str:
    """Format algorithm steps as LaTeX algorithm environment.
    
    Args:
        steps: List of algorithm steps (can include LaTeX commands)
        caption: Algorithm caption
        label: LaTeX label
    """
    latex = f"""\\begin{{algorithm}}[t]
\\caption{{{caption}}}
\\label{{{label}}}
\\begin{{algorithmic}}[1]
"""
    
    for step in steps:
        latex += f"\\State {step}\n"
    
    latex += """\\end{algorithmic}
\\end{algorithm}"""
    
    return json.dumps({
        "latex": latex,
        "reference": f"Algorithm~\\ref{{{label}}}",
    }, indent=2)


async def format_equation(
    equation: str,
    label: Optional[str] = None,
) -> str:
    """Format a mathematical equation.
    
    Args:
        equation: LaTeX math content (without $$ or equation environment)
        label: Optional label for referencing
    """
    if label:
        latex = f"""\\begin{{equation}}
\\label{{{label}}}
{equation}
\\end{{equation}}"""
        ref = f"Equation~\\ref{{{label}}}"
    else:
        latex = f"""\\begin{{equation}}
{equation}
\\end{{equation}}"""
        ref = None
    
    return json.dumps({
        "latex": latex,
        "reference": ref,
    }, indent=2)


async def create_paper_skeleton(
    title: str,
    conference: str = "neurips",
    sections: Optional[list[str]] = None,
) -> str:
    """Create a paper skeleton with section headers.
    
    This creates the structure - you fill in the content.
    """
    if sections is None:
        sections = ["Introduction", "Related Work", "Method", "Experiments", "Conclusion"]
    
    # Section labels
    labels = {
        "introduction": "intro",
        "related work": "related",
        "method": "method",
        "experiments": "experiments",
        "conclusion": "conclusion",
        "discussion": "discussion",
        "background": "background",
    }
    
    content = ""
    for section in sections:
        section_lower = section.lower()
        label = labels.get(section_lower, section_lower.replace(" ", "_"))
        content += f"""
\\section{{{section}}}
\\label{{sec:{label}}}

% TODO: Write {section} content here

"""
    
    return json.dumps({
        "sections": sections,
        "skeleton": content,
        "note": "Fill in each section with your content",
    }, indent=2)


async def get_paper_context(
    paper_ids: list[str],
) -> str:
    """Get context from cached papers to inform writing.
    
    Retrieves titles, abstracts, and key info from papers
    to help the LLM generate relevant content.
    """
    context = []
    
    for paper_id in paper_ids:
        paper = await papers_cache.get_paper(paper_id)
        if paper:
            context.append({
                "id": paper.paper_id,
                "title": paper.title,
                "abstract": paper.abstract,
                "authors": paper.authors[:3],
                "categories": paper.categories,
                "year": paper.published[:4] if paper.published else None,
            })
    
    return json.dumps({
        "count": len(context),
        "papers": context,
        "note": "Use this context to inform your writing",
    }, indent=2)


async def validate_latex(
    latex_content: str,
) -> str:
    """Basic validation of LaTeX content.
    
    Checks for common issues like unmatched braces, environments.
    """
    issues = []
    
    # Check brace balance
    open_braces = latex_content.count("{")
    close_braces = latex_content.count("}")
    if open_braces != close_braces:
        issues.append(f"Unbalanced braces: {open_braces} open, {close_braces} close")
    
    # Check environment balance
    import re
    begins = re.findall(r"\\begin\{(\w+)\}", latex_content)
    ends = re.findall(r"\\end\{(\w+)\}", latex_content)
    
    begin_counts = {}
    for env in begins:
        begin_counts[env] = begin_counts.get(env, 0) + 1
    
    end_counts = {}
    for env in ends:
        end_counts[env] = end_counts.get(env, 0) + 1
    
    for env in set(list(begin_counts.keys()) + list(end_counts.keys())):
        b = begin_counts.get(env, 0)
        e = end_counts.get(env, 0)
        if b != e:
            issues.append(f"Unbalanced {env} environment: {b} begins, {e} ends")
    
    # Check for common mistakes
    if "\\ref{" in latex_content and "~\\ref{" not in latex_content:
        issues.append("Consider using ~\\ref{} for non-breaking space before references")
    
    return json.dumps({
        "valid": len(issues) == 0,
        "issues": issues,
        "char_count": len(latex_content),
        "word_count": len(latex_content.split()),
    }, indent=2)


async def save_to_file(
    content: str,
    filename: str,
    output_dir: str = "./output",
) -> str:
    """Save content to a file in the output directory."""
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    file_path = output_path / filename
    file_path.write_text(content)
    
    return json.dumps({
        "success": True,
        "path": str(file_path),
        "size": len(content),
    }, indent=2)
